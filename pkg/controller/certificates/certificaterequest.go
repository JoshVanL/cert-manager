/*
Copyright 2019 The Jetstack cert-manager contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package certificates

import (
	"bytes"
	"context"
	"crypto"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"hash/fnv"

	corev1 "k8s.io/api/core/v1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	apiutil "github.com/jetstack/cert-manager/pkg/api/util"
	"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1alpha1"
	logf "github.com/jetstack/cert-manager/pkg/logs"
	"github.com/jetstack/cert-manager/pkg/util/pki"
)

const (
	certNameLabelKey = "acme.cert-manager.io/order-name"
)

// return an error on failure. If retrieval is succesful, the certificate data
// and private key will be stored in the named secret
func (c *Controller) issue(ctx context.Context, issuer v1alpha1.GenericIssuer, key crypto.Signer, crt *v1alpha1.Certificate) error {
	log := logf.FromContext(ctx)

	csr, err := pki.GenerateCSR(issuer, crt)
	if err != nil {
		return err
	}

	if key == nil {
		log.Info("generating new private key")
		key, err = c.generateNewPrivateKey(ctx, crt)
		if err != nil {
			return err
		}
	}

	csrBytes, err := pki.EncodeCSR(csr, key)
	if err != nil {
		return err
	}

	csrPEM := pem.EncodeToMemory(&pem.Block{
		Type: "CERTIFICATE REQUEST", Bytes: csrBytes,
	})

	cr, err := c.getCertificateRequestForCertificate(crt, csrPEM)
	if err != nil && !apierrors.IsNotFound(err) {
		log.WithValues(
			logf.RelatedResourceNamespaceKey, cr.Namespace,
			logf.RelatedResourceNameKey, cr.Name,
			logf.RelatedResourceKindKey, v1alpha1.CertificateRequestKind,
		).Error(err, "error getting existing CertificateRequest resource")
		return err
	}

	// create CertificateRequest
	if cr == nil {
		// return here and wait till next sync to catch CertificateRequest update
		log.Info("creating CertificateRequest to issue certificate")
		return c.createCertificateRequest(crt, csrPEM)
	}

	ready := apiutil.CertificateRequestHasCondition(cr, v1alpha1.CertificateRequestCondition{
		Type:   v1alpha1.CertificateRequestConditionReady,
		Status: v1alpha1.ConditionTrue,
	})
	if !ready {
		// CertificateRequest is not ready yet so wait for next sync
		return nil
	}

	keyPEM, err := pki.EncodePrivateKey(key)
	if err != nil {
		return err
	}

	// Update referenced secret with ready certificate
	if _, err := c.updateSecret(ctx, crt, crt.Namespace, cr.Status.Certificate, keyPEM, cr.Status.CA); err != nil {
		s := messageErrorSavingCertificate + err.Error()
		log.Error(err, "error saving certificate")
		c.Recorder.Event(crt, corev1.EventTypeWarning, errorSavingCertificate, s)
		return err
	}

	certx509, err := pki.DecodeX509CertificateBytes(cr.Status.Certificate)
	if err != nil {
		return err
	}

	c.setCertificateStatus(crt, key, certx509)

	c.Recorder.Event(crt, corev1.EventTypeNormal, successCertificateIssued, "Certificate issued successfully")
	// as we have just written a certificate, we should schedule it for renewal
	c.scheduleRenewal(ctx, crt)

	return nil
}

func (c *Controller) createCertificateRequest(crt *v1alpha1.Certificate, csrPEM []byte) error {
	cr, err := buildCertificateRequest(crt, csrPEM)
	if err != nil {
		return err
	}

	_, err = c.CMClient.CertmanagerV1alpha1().CertificateRequests(crt.Namespace).Create(cr)
	if err != nil {
		return err
	}

	return nil
}

func (c *Controller) certificateRequestMatchesCertificateSpec(cert *v1alpha1.Certificate, csrPEM []byte, cr *v1alpha1.CertificateRequest) (bool, []string) {
	var errs []string

	if cert == nil || cr == nil {
		errs = append(errs, "certificate or certificate request nil")
		return false, errs
	}

	if cert.Spec.IsCA != cr.Spec.IsCA {
		errs = append(errs, "certificate IsCA does not match certificate request")
	}

	if cert.Spec.Duration != nil {
		if cr.Spec.Duration == nil ||
			cert.Spec.Duration.String() != cr.Spec.Duration.String() {
			errs = append(errs, "certificate duration does not match certificate request duration")
		}
	} else if cr.Spec.Duration != nil {
		errs = append(errs, "certificate duration not defined in certificate but is in certificate request")
	}

	if cert.Spec.IssuerRef != cr.Spec.IssuerRef {
		errs = append(errs, "certificate issuer reference does not match certificate request")
	}

	if csrPEM == nil || !bytes.Equal(csrPEM, cr.Spec.CSRPEM) {
		errs = append(errs, "certificate request CSR PEM does not match that generated by certificate")
	}

	return len(errs) == 0, errs
}

func buildCertificateRequest(crt *v1alpha1.Certificate, csr []byte) (*v1alpha1.CertificateRequest, error) {
	hash, err := hashCertificate(crt.Spec)
	if err != nil {
		return nil, err
	}

	return &v1alpha1.CertificateRequest{
		ObjectMeta: metav1.ObjectMeta{
			Name:      fmt.Sprintf("%s-%d", crt.Name, hash),
			Namespace: crt.Namespace,
			Labels:    certificateRequestLabelsForCertificate(crt),
		},
		Spec: v1alpha1.CertificateRequestSpec{
			CSRPEM:    csr,
			Duration:  crt.Spec.Duration.DeepCopy(),
			IsCA:      crt.Spec.IsCA,
			IssuerRef: crt.Spec.IssuerRef,
		},
	}, nil
}

func hashCertificate(crtSpec v1alpha1.CertificateSpec) (uint32, error) {
	crtSpecBytes, err := json.Marshal(crtSpec)
	if err != nil {
		return 0, err
	}

	hashF := fnv.New32()
	_, err = hashF.Write(crtSpecBytes)
	if err != nil {
		return 0, err
	}

	return hashF.Sum32(), nil
}

func (c *Controller) getCertificateRequestForCertificate(crt *v1alpha1.Certificate, csr []byte) (*v1alpha1.CertificateRequest, error) {
	expectedCertificateRequest, err := buildCertificateRequest(crt, csr)
	if err != nil {
		return nil, err
	}

	cr, err := c.certificateRequestLister.CertificateRequests(expectedCertificateRequest.Namespace).
		Get(expectedCertificateRequest.Name)
	if err != nil {
		return nil, err
	}

	return cr, nil
}

func certificateRequestLabelsForCertificate(c *v1alpha1.Certificate) map[string]string {
	return map[string]string{
		certNameLabelKey: c.Name,
	}
}
